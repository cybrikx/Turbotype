<!-- Copyright (c) 2025 cybrikx - MIT License -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typing Speed Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Roboto Mono', monospace;
        }

        body {
            display: flex;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a1a, #252525);
            color: #fff;
            overflow: hidden;
        }

        .container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 850px;
            text-align: center;
            padding: 25px;
            background: rgba(26, 26, 26, 0.9);
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .header {
            margin-bottom: 20px;
        }

        .logo {
            font-size: 2rem;
            font-weight: 700;
            color: #f1c40f;
            text-shadow: 0 0 15px rgba(241, 196, 15, 0.7);
            animation: glow 2s ease-in-out infinite alternate;
        }

        .options {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .option-btn {
            padding: 10px 15px;
            font-size: 0.95rem;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option-btn.active {
            background: #f1c40f;
            color: #1a1a1a;
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(241, 196, 15, 0.5);
        }

        .option-btn:hover {
            background: #444;
            transform: scale(1.05);
        }

        .language {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 15px;
        }

        .instructions {
            font-size: 0.95rem;
            color: #bbb;
            margin-bottom: 20px;
            animation: fadeIn 1s ease;
        }

        .typing-area {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            position: relative;
            user-select: none;
            outline: none;
        }

        #textDisplay {
            font-size: 1.4rem;
            line-height: 2.2;
            min-height: 120px;
            position: relative;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #textDisplay .word {
            display: inline-block;
            margin-right: 10px;
            animation: fadeIn 0.5s ease forwards;
        }

        #textDisplay .letter {
            transition: all 0.2s ease;
            position: relative;
        }

        #textDisplay .pending {
            color: #888;
        }

        #textDisplay .correct {
            color: #fff;
            animation: pop 0.2s ease;
        }

        #textDisplay .incorrect {
            color: #ff5555;
            animation: shake 0.2s ease;
        }

        #textDisplay .current-word {
            background: rgba(241, 196, 15, 0.3);
            padding: 3px 6px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(241, 196, 15, 0.3);
        }

        .cursor {
            display: inline-block;
            width: 2px;
            height: 1.4rem;
            background: #f1c40f;
            animation: blink 0.8s step-end infinite;
            vertical-align: middle;
            position: relative;
            top: -2px;
        }

        #timeLeft {
            font-size: 1.2rem;
            color: #f1c40f;
            margin-bottom: 20px;
            animation: fadeIn 1s ease;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress {
            height: 100%;
            background: #f1c40f;
            width: 0;
            transition: width 0.3s ease;
            animation: progressFill 0.3s ease;
        }

        .results {
            display: none;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        .results.active {
            display: flex;
            animation: slideUp 0.5s ease;
        }

        .metrics {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .metric {
            text-align: center;
        }

        .metric-label {
            font-size: 0.95rem;
            color: #888;
        }

        .metric-value {
            font-size: 1.9rem;
            font-weight: 700;
        }

        .metric-value.wpm {
            color: #f1c40f;
        }

        .graph {
            width: 100%;
            max-width: 650px;
            height: 180px;
            background: #252525;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        #resetBtn {
            display: none;
            padding: 12px 25px;
            font-size: 1.1rem;
            background: #ff4444;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }

        #resetBtn:hover {
            background: #cc0000;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.7);
        }

        .shortcuts {
            margin-top: 15px;
            font-size: 0.85rem;
            color: #888;
        }

        .shortcuts span {
            background: #333;
            padding: 3px 6px;
            border-radius: 3px;
            margin: 0 3px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(241, 196, 15, 0.5); }
            to { text-shadow: 0 0 20px rgba(241, 196, 15, 0.8); }
        }

        @keyframes progressFill {
            from { width: 0; }
            to { width: var(--progress-width); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">Typing Speed Test</div>
        </div>
        <div class="options">
            <button class="option-btn mode active" data-mode="time">time</button>
            <button class="option-btn mode" data-mode="words">words</button>
            <button class="option-btn duration active" data-duration="15">15</button>
            <button class="option-btn duration" data-duration="30">30</button>
            <button class="option-btn duration" data-duration="60">60</button>
            <button class="option-btn duration" data-duration="120">120</button>
        </div>
        <div class="language">dev by @waqarro1</div>
        <div class="instructions">Start typing to begin. The current word is highlighted. Press <span style="background:#333;padding:2px 5px;border-radius:3px;">Tab + Enter</span> to reset.</div>
        <div class="typing-area" tabindex="0" id="typingArea">
            <div id="textDisplay"></div>
        </div>
        <div id="timeLeft">Time Left: 15s</div>
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
        <div class="results" id="results">
            <div class="metrics">
                <div class="metric">
                    <div class="metric-label">wpm</div>
                    <div class="metric-value wpm" id="wpm">0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">raw</div>
                    <div class="metric-value" id="rawWpm">0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">acc</div>
                    <div class="metric-value" id="accuracy">0%</div>
                </div>
                <div class="metric">
                    <div class="metric-label">chars</div>
                    <div class="metric-value" id="characters">0/0/0/0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">consistency</div>
                    <div class="metric-value" id="consistency">0%</div>
                </div>
            </div>
            <div class="graph">
                <canvas id="wpmGraph"></canvas>
            </div>
        </div>
        <button id="resetBtn">Reset</button>
        <div class="shortcuts">
            <span>tab</span> + <span>enter</span> - restart test
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        const textDisplay = document.getElementById('textDisplay');
        const timeLeft = document.getElementById('timeLeft');
        const results = document.getElementById('results');
        const wpmDisplay = document.getElementById('wpm');
        const rawWpmDisplay = document.getElementById('rawWpm');
        const accuracyDisplay = document.getElementById('accuracy');
        const charactersDisplay = document.getElementById('characters');
        const consistencyDisplay = document.getElementById('consistency');
        const wpmGraphCanvas = document.getElementById('wpmGraph');
        const progress = document.getElementById('progress');
        const options = document.querySelector('.options');
        const language = document.querySelector('.language');
        const instructions = document.querySelector('.instructions');
        const resetBtn = document.getElementById('resetBtn');
        const typingArea = document.getElementById('typingArea');
        const modeButtons = document.querySelectorAll('.mode');
        const durationButtons = document.querySelectorAll('.duration');

        const texts = {
            normal: "end system little year also group home play set than say back head word long this life stand should down large public form interest which however state day word little tell late this how",
            level1: [
                "Hello world. This is an easy sentence for beginners to practice typing.",
                "The dog runs fast. It loves to play in the park every morning.",
                "A red apple sits on the table next to a blue cup."
            ].join(' '),
            level2: [
                "The sun sets slowly behind the mountain, casting a warm glow over the valley.",
                "Birds sing sweetly in the trees as the breeze carries their melody.",
                "A small boat floats gently on the calm lake under the starry sky."
            ].join(' '),
            level3: [
                "Programming is fun but challenging. It requires focus and persistence to master.",
                "The old library holds many secrets within its dusty books and quiet corners.",
                "A bright kite soars high above the festival, dancing with the wind."
            ].join(' '),
            level4: [
                "A journey of a thousand miles begins with a single step. Keep moving forward.",
                "The clock ticks steadily, reminding us to cherish every moment we have.",
                "Ancient ruins whisper tales of forgotten civilizations to curious explorers."
            ].join(' '),
            level5: [
                "The cat quietly sneaked into the room, unnoticed by the sleeping dog.",
                "Stars twinkle brightly in the night sky, guiding travelers through the darkness.",
                "A skilled chef crafts delicious meals with fresh ingredients and bold flavors."
            ].join(' '),
            level6: "Artificial intelligence is transforming industries, from healthcare to finance.",
            level7: "To achieve greatness, one must embrace failure as a stepping stone to success.",
            level8: "The intricate patterns of the snowflake reveal the beauty of nature's design.",
            level9: "Quantum computing promises to revolutionize technology, but it's still in its infancy.",
            level10: "Mastering typing requires dedication, muscle memory, and consistent practice over time."
        };

        let currentText = '';
        let words = [];
        let currentWordIndex = 0;
        let currentCharIndex = 0;
        let startTime, timerInterval, metricInterval;
        let correctChars = 0;
        let incorrectChars = 0;
        let totalCharsTyped = 0;
        let missedChars = 0;
        let extraChars = 0;
        let wpmHistory = [];
        let mode = 'time';
        let duration = 15;
        let testActive = false;
        let testEnded = false;
        let chart;
        let textInputValue = '';
        let isProcessingKey = false;

        function initializeTest() {
            try {
                currentText = texts['normal'];
                words = currentText.split(' ').filter(word => word.length > 0);
                currentWordIndex = 0;
                currentCharIndex = 0;
                correctChars = 0;
                incorrectChars = 0;
                totalCharsTyped = 0;
                missedChars = 0;
                extraChars = 0;
                wpmHistory = [];
                testActive = false;
                testEnded = false;
                textInputValue = '';

                // Clear and rebuild text display
                textDisplay.innerHTML = '';
                words.forEach((word, idx) => {
                    const wordSpan = document.createElement('span');
                    wordSpan.classList.add('word');
                    if (idx === 0) wordSpan.classList.add('current-word');
                    word.split('').forEach((char, charIdx) => {
                        const span = document.createElement('span');
                        span.textContent = char;
                        span.classList.add('letter', 'pending');
                        span.dataset.charIndex = charIdx;
                        wordSpan.appendChild(span);
                    });
                    wordSpan.appendChild(document.createTextNode(' '));
                    textDisplay.appendChild(wordSpan);
                });

                // Add cursor
                const cursor = document.createElement('span');
                cursor.classList.add('cursor');
                const firstWord = textDisplay.querySelector('.word');
                if (firstWord && firstWord.firstChild) {
                    firstWord.insertBefore(cursor, firstWord.firstChild);
                } else {
                    console.warn('No valid word or child found, appending cursor to textDisplay');
                    textDisplay.appendChild(cursor);
                }

                // Reset UI elements
                results.style.display = 'none'; // Ensure results are hidden
                progress.style.width = '0';
                if (chart) {
                    chart.destroy();
                    chart = null;
                }
                clearInterval(timerInterval);
                clearInterval(metricInterval);
                timeLeft.style.display = 'block';
                progress.parentElement.style.display = 'none';
                resetBtn.style.display = 'none';
                options.style.display = 'flex';
                language.style.display = 'block';
                instructions.style.display = 'block';

                // Reset metrics
                wpmDisplay.textContent = '0';
                rawWpmDisplay.textContent = '0';
                accuracyDisplay.textContent = '0%';
                charactersDisplay.textContent = '0/0/0/0';
                consistencyDisplay.textContent = '0%';

                typingArea.focus();
            } catch (error) {
                console.error('Error initializing test:', error);
            }
        }

        function startTimer() {
            try {
                startTime = new Date();
                timerInterval = setInterval(() => {
                    const elapsed = Math.floor((new Date() - startTime) / 1000);
                    const remaining = Math.max(0, duration - elapsed);
                    timeLeft.textContent = `Time Left: ${remaining}s`;
                    const progressWidth = ((duration - remaining) / duration) * 100;
                    progress.style.setProperty('--progress-width', `${progressWidth}%`);
                    if (remaining <= 0) {
                        endTest();
                    }
                }, 1000);
                metricInterval = setInterval(updateMetrics, 1000);
                timeLeft.style.display = 'block';
                progress.parentElement.style.display = 'block';
            } catch (error) {
                console.error('Error starting timer:', error);
            }
        }

        function updateMetrics() {
            if (!testActive || !startTime) return;
            try {
                const elapsedSeconds = (new Date() - startTime) / 1000;
                const minutes = elapsedSeconds / 60;
                const typedWords = textInputValue.trim().split(/\s+/).filter(w => w.length > 0);
                const correctWords = typedWords.slice(0, currentWordIndex).filter((word, i) => word === words[i]).length;
                const wpm = minutes > 0 ? Math.round(correctWords / minutes) : 0;
                const rawWpm = minutes > 0 ? Math.round(totalCharsTyped / 5 / minutes) : 0;
                const accuracy = (correctChars + incorrectChars + missedChars) > 0 ? 
                    Math.round((correctChars / (correctChars + incorrectChars + missedChars)) * 100) : 0;
                const consistency = calculateConsistency(wpmHistory);

                wpmDisplay.textContent = wpm || 0;
                rawWpmDisplay.textContent = rawWpm || 0;
                accuracyDisplay.textContent = `${accuracy || 0}%`;
                charactersDisplay.textContent = `${correctChars}/${incorrectChars}/${missedChars}/${extraChars}`;
                consistencyDisplay.textContent = `${Math.round(consistency) || 0}%`;

                wpmHistory.push(wpm);
                if (wpmHistory.length > elapsedSeconds) wpmHistory.shift();
                if (chart) {
                    chart.data.labels = Array.from({ length: wpmHistory.length }, (_, i) => i + 1);
                    chart.data.datasets[0].data = wpmHistory;
                    chart.update();
                }
            } catch (error) {
                console.error('Error updating metrics:', error);
            }
        }

        function calculateConsistency(history) {
            try {
                if (history.length < 2) return 0;
                const mean = history.reduce((a, b) => a + b, 0) / history.length || 0;
                const variance = history.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / history.length || 0;
                const stdDev = Math.sqrt(variance);
                return mean > 0 ? Math.max(0, 100 - (stdDev / mean) * 100) : 0;
            } catch (error) {
                console.error('Error calculating consistency:', error);
                return 0;
            }
        }

        function drawGraph() {
            try {
                chart = new Chart(wpmGraphCanvas, {
                    type: 'line',
                    data: {
                        labels: Array.from({ length: wpmHistory.length }, (_, i) => i + 1),
                        datasets: [{
                            label: 'WPM',
                            data: wpmHistory,
                            borderColor: '#f1c40f',
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { x: { display: false }, y: { beginAtZero: true } },
                        plugins: { legend: { display: false } }
                    }
                });
            } catch (error) {
                console.error('Error drawing graph:', error);
            }
        }

        function endTest() {
            try {
                testActive = false;
                testEnded = true;
                clearInterval(timerInterval);
                clearInterval(metricInterval);
                updateMetrics();
                results.style.display = 'flex';
                drawGraph();
                resetBtn.style.display = 'block';
                options.style.display = 'none';
                language.style.display = 'none';
                instructions.style.display = 'none';
                timeLeft.style.display = 'none';
                progress.parentElement.style.display = 'none';
                typingArea.focus();
            } catch (error) {
                console.error('Error ending test:', error);
            }
        }

        function updateDisplay() {
            try {
                const typedWords = textInputValue.trim().split(/\s+/).filter(w => w.length > 0);
                const currentTypedWord = typedWords[currentWordIndex] || '';
                const cursor = textDisplay.querySelector('.cursor');

                Array.from(textDisplay.children).forEach((wordSpan, wordIdx) => {
                    wordSpan.classList.remove('current-word');
                    const letters = wordSpan.querySelectorAll('.letter');
                    letters.forEach(letter => {
                        letter.classList.remove('correct', 'incorrect');
                        letter.classList.add('pending');
                    });
                });

                for (let wordIdx = 0; wordIdx <= currentWordIndex; wordIdx++) {
                    const wordSpan = textDisplay.children[wordIdx];
                    const word = words[wordIdx];
                    const typedWord = typedWords[wordIdx] || '';
                    const letters = wordSpan.querySelectorAll('.letter');

                    if (wordIdx === currentWordIndex) {
                        wordSpan.classList.add('current-word');
                    }

                    word.split('').forEach((char, letterIdx) => {
                        const letterSpan = letters[letterIdx];
                        const typedChar = typedWord[letterIdx];

                        if (typedChar === undefined) {
                            letterSpan.classList.add('pending');
                        } else if (typedChar === char) {
                            letterSpan.classList.remove('pending', 'incorrect');
                            letterSpan.classList.add('correct');
                        } else {
                            letterSpan.classList.remove('pending', 'correct');
                            letterSpan.classList.add('incorrect');
                        }
                    });

                    if (typedWord.length > word.length) {
                        extraChars += typedWord.length - word.length;
                    }

                    if (wordIdx === currentWordIndex && cursor) {
                        const nextCharIndex = currentTypedWord.length;
                        if (nextCharIndex < letters.length) {
                            letters[nextCharIndex].insertAdjacentElement('beforebegin', cursor);
                        } else {
                            wordSpan.insertAdjacentElement('beforeend', cursor);
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating display:', error);
            }
        }

        typingArea.addEventListener('keydown', (e) => {
            if (isProcessingKey) return;
            isProcessingKey = true;

            try {
                if (e.key === 'Tab' && e.getModifierState('Tab')) {
                    e.preventDefault();
                    isProcessingKey = false;
                    return;
                }

                if (testEnded) {
                    e.preventDefault();
                    isProcessingKey = false;
                    return;
                }

                if (!testActive && e.key.length === 1 && /[a-zA-Z]/.test(e.key)) {
                    testActive = true;
                    startTimer();
                    options.style.display = 'none';
                    language.style.display = 'none';
                    instructions.style.display = 'none';
                }

                if (!testActive) {
                    isProcessingKey = false;
                    return;
                }

                if (e.key === 'Enter' && e.getModifierState('Tab')) {
                    e.preventDefault();
                    initializeTest();
                    isProcessingKey = false;
                    return;
                }

                if (e.key.length === 1 && /[a-zA-Z]/.test(e.key)) {
                    textInputValue += e.key;
                    totalCharsTyped++;
                    currentCharIndex++;
                } else if (e.key === 'Backspace') {
                    if (textInputValue.length > 0) {
                        textInputValue = textInputValue.slice(0, -1);
                        totalCharsTyped = Math.max(0, totalCharsTyped - 1);
                        currentCharIndex = Math.max(0, currentCharIndex - 1);
                        if (extraChars > 0) extraChars--;
                        else if (incorrectChars > 0) incorrectChars--;
                        else if (correctChars > 0) correctChars--;
                    }
                } else if (e.key === ' ' && textInputValue.trim().length > 0) {
                    const typedWords = textInputValue.trim().split(/\s+/).filter(w => w.length > 0);
                    const currentTypedWord = typedWords[typedWords.length - 1] || '';

                    if (currentTypedWord === words[currentWordIndex]) {
                        correctChars += words[currentWordIndex].length;
                    } else {
                        incorrectChars += currentTypedWord.length;
                        missedChars += Math.max(0, words[currentWordIndex].length - currentTypedWord.length);
                    }

                    textInputValue += ' ';
                    currentWordIndex++;
                    currentCharIndex = 0;
                    if (currentWordIndex >= words.length) {
                        endTest();
                        isProcessingKey = false;
                        return;
                    }
                } else {
                    isProcessingKey = false;
                    return;
                }

                updateDisplay();
                updateMetrics();
                isProcessingKey = false;
            } catch (error) {
                console.error('Error handling keydown:', error);
                isProcessingKey = false;
            }
        });

        resetBtn.addEventListener('click', () => {
            try {
                initializeTest();
            } catch (error) {
                console.error('Error resetting test:', error);
            }
        });

        modeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                try {
                    modeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    mode = btn.dataset.mode;
                    initializeTest();
                } catch (error) {
                    console.error('Error changing mode:', error);
                }
            });
        });

        durationButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                try {
                    durationButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    duration = parseInt(btn.dataset.duration);
                    timeLeft.textContent = `Time Left: ${duration}s`;
                    initializeTest();
                } catch (error) {
                    console.error('Error changing duration:', error);
                }
            });
        });

        typingArea.addEventListener('click', () => {
            try {
                typingArea.focus();
            } catch (error) {
                console.error('Error focusing typing area:', error);
            }
        });

        // Initial setup
        initializeTest();
    </script>
</body>

    </script>
</body>

    </script>
</body>

    </script>
</body>
</html>
<!-- Copyright (c) 2025 cybrikx - MIT License -->
